#!/usr/bin/env node
/**
 * generate-models.js
 *
 * Parses api-types.d.ts and generates a clean barrel file (models.ts)
 * that re-exports all schemas with developer-friendly names.
 *
 * Usage: node scripts/generate-models.js
 */

const fs = require("node:fs");
const path = require("node:path");

const API_TYPES_PATH = path.join(__dirname, "../src/lib/api-types.d.ts");
const MODELS_OUTPUT_PATH = path.join(__dirname, "../src/lib/models.ts");

// Schema name mappings: { originalName: friendlyName }
// Some schemas have verbose "Read" suffix that we can simplify
const NAME_MAPPINGS = {
  UserRead: "User",
  SessionRead: "Session",
  SessionListResponse: "SessionList",
  MemberRead: "Member",
  OrganizationRead: "Organization",
  InvitationRead: "Invitation",
  CommunicationPreferencesRead: "CommunicationPreferences",
};

// Group schemas by category for organized output
const CATEGORIES = {
  "User & Authentication": [
    "UserRead",
    "UserUpdate",
    "UserDeleteRequest",
    "UserDeleteResponse",
    "UserExportRequest",
    "UserExportResponse",
  ],
  Sessions: ["SessionRead", "SessionListResponse", "SessionRevokeResponse"],
  "MFA (Multi-Factor Authentication)": [
    "MFASetupResponse",
    "MFAVerifyRequest",
    "MFAVerifyResponse",
    "MFADisableRequest",
    "MFADisableResponse",
  ],
  Organizations: [
    "OrganizationRead",
    "OrganizationCreate",
    "OrganizationUpdate",
    "MemberRead",
  ],
  Invitations: ["InvitationRead", "InvitationCreate"],
  "Communication Preferences": [
    "CommunicationPreferencesRead",
    "CommunicationPreferencesUpdate",
  ],
  "Device Tokens (Push Notifications)": [
    "DeviceTokenRequest",
    "DeviceTokenDeleteRequest",
    "DeviceTokenResponse",
  ],
  Consent: ["ConsentSignRequest"],
  "Telemetry / Analytics": ["TelemetryEvent", "TelemetryResponse"],
  Admin: ["ImpersonationRequest"],
  Errors: ["HTTPValidationError", "ValidationError"],
};

function extractSchemaNames(content) {
  // Find the schemas section - it starts with "schemas: {" and ends before "responses:" or end of components
  const schemasStartMatch = content.match(/schemas:\s*\{/);
  if (!schemasStartMatch) {
    console.error("Could not find schemas section in api-types.d.ts");
    process.exit(1);
  }

  const startIndex = schemasStartMatch.index + schemasStartMatch[0].length;

  // Find end of schemas section (next sibling property at same level or end of components)
  // Look for patterns like "    };\n    responses:" or similar
  const afterSchemas = content.slice(startIndex);
  const endMatch = afterSchemas.match(
    /\n\s{4}\};\n\s{4}(responses|parameters|requestBodies|headers|pathItems):/,
  );

  let schemasBlock;
  if (endMatch) {
    schemasBlock = afterSchemas.slice(0, endMatch.index);
  } else {
    // Fallback: take until we see the closing of schemas
    const fallbackEnd = afterSchemas.indexOf("\n    };");
    schemasBlock =
      fallbackEnd > 0
        ? afterSchemas.slice(0, fallbackEnd)
        : afterSchemas.slice(0, 10000);
  }

  const schemaNames = [];

  // Match schema names - they are indented with 8 spaces (2 levels inside components.schemas)
  // Pattern: 8 spaces, identifier, colon, space, brace OR 8 spaces, comment, newline, 8 spaces, identifier
  const regex = /^\s{8}(\w+):\s*\{/gm;
  let match = regex.exec(schemasBlock);
  while (match !== null) {
    schemaNames.push(match[1]);
    match = regex.exec(schemasBlock);
  }

  return schemaNames;
}

function getFriendlyName(originalName) {
  return NAME_MAPPINGS[originalName] || originalName;
}

function generateModelsFile(schemaNames) {
  const lines = [];

  // Header
  lines.push(`/**`);
  lines.push(` * ðŸ¬ Type Sugar - Clean re-exports of generated API types`);
  lines.push(` *`);
  lines.push(` * Instead of: components['schemas']['UserRead']`);
  lines.push(` * Just use:   User`);
  lines.push(` *`);
  lines.push(` * AUTO-GENERATED by scripts/generate-models.js`);
  lines.push(` * Run: pnpm generate:models`);
  lines.push(` */`);
  lines.push(``);
  lines.push(`import type { components } from './api-types';`);
  lines.push(``);

  // Track which schemas we've already added
  const addedSchemas = new Set();

  // Generate exports by category
  for (const [category, schemas] of Object.entries(CATEGORIES)) {
    const validSchemas = schemas.filter(
      (s) => schemaNames.includes(s) && !addedSchemas.has(s),
    );
    if (validSchemas.length === 0) continue;

    lines.push(
      `// =============================================================================`,
    );
    lines.push(`// ${category}`);
    lines.push(
      `// =============================================================================`,
    );
    lines.push(``);

    for (const schema of validSchemas) {
      const friendlyName = getFriendlyName(schema);
      lines.push(
        `export type ${friendlyName} = components['schemas']['${schema}'];`,
      );
      addedSchemas.add(schema);
    }
    lines.push(``);
  }

  // Add any uncategorized schemas
  const uncategorized = schemaNames.filter((s) => !addedSchemas.has(s));
  if (uncategorized.length > 0) {
    lines.push(
      `// =============================================================================`,
    );
    lines.push(`// Other`);
    lines.push(
      `// =============================================================================`,
    );
    lines.push(``);
    for (const schema of uncategorized) {
      const friendlyName = getFriendlyName(schema);
      lines.push(
        `export type ${friendlyName} = components['schemas']['${schema}'];`,
      );
    }
    lines.push(``);
  }

  return lines.join("\n");
}

function main() {
  console.log("ðŸ“– Reading api-types.d.ts...");
  const content = fs.readFileSync(API_TYPES_PATH, "utf-8");

  console.log("ðŸ” Extracting schema names...");
  const schemaNames = extractSchemaNames(content);
  console.log(`   Found ${schemaNames.length} schemas`);

  console.log("âœï¸  Generating models.ts...");
  const output = generateModelsFile(schemaNames);

  fs.writeFileSync(MODELS_OUTPUT_PATH, output, "utf-8");
  console.log(`âœ… Generated ${MODELS_OUTPUT_PATH}`);
  console.log("");
  console.log("Exported types:");

  // Print summary
  for (const [category, schemas] of Object.entries(CATEGORIES)) {
    const validSchemas = schemas.filter((s) => schemaNames.includes(s));
    if (validSchemas.length === 0) continue;
    console.log(`  ${category}:`);
    for (const s of validSchemas) {
      const friendly = getFriendlyName(s);
      if (friendly !== s) {
        console.log(`    - ${friendly} (from ${s})`);
      } else {
        console.log(`    - ${friendly}`);
      }
    }
  }
}

main();
